<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bombard Cannon Simulator</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #cce7ff; /* light blue page background */
      color: #111827;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0;
      padding: 20px;
    }

    h1 {
      font-size: 1.5rem;
      margin-bottom: 0.25rem;
    }

    .subtitle {
      font-size: 0.9rem;
      color: #374151;
      margin-bottom: 1rem;
      text-align: center;
      max-width: 700px;
    }

    .controls {
      background: #e5e7eb;
      border-radius: 12px;
      padding: 16px 20px;
      display: flex;
      align-items: center;
      gap: 16px;
      margin-bottom: 16px;
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.2);
      flex-wrap: wrap;
      justify-content: center;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    label {
      font-size: 0.85rem;
      color: #111827;
    }

    input[type="range"] {
      width: 220px;
    }

    .value-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 2px 8px;
      background: #111827;
      border-radius: 999px;
      font-size: 0.8rem;
      color: #f9fafb;
      min-width: 52px;
      text-align: center;
    }

    button {
      border: none;
      padding: 10px 18px;
      border-radius: 999px;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      background: linear-gradient(135deg, #22c55e, #16a34a);
      color: #022c22;
      box-shadow: 0 10px 25px rgba(16, 185, 129, 0.45);
      transition: transform 0.08s ease, box-shadow 0.08s ease, filter 0.08s ease;
      white-space: nowrap;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 14px 30px rgba(16, 185, 129, 0.6);
      filter: brightness(1.05);
    }

    button:active {
      transform: translateY(1px);
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.5);
      filter: brightness(0.97);
    }

    canvas {
      background: #87ceeb; /* sky blue */
      border-radius: 16px;
      box-shadow: 0 20px 45px rgba(0, 0, 0, 0.4);
      border: 1px solid #9ca3af;
    }

    .note {
      margin-top: 10px;
      font-size: 0.8rem;
      color: #374151;
      max-width: 700px;
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>Bombard Cannon Simulator</h1>
  <div class="subtitle">
    A massive stone-throwing bombard like those used at the Siege of Constantinople (1453). Adjust barrel angle,
    powder charge, and fuse time, then light the fuse and watch the stone fly.
  </div>

  <div class="controls">
    <div class="control-group">
      <label for="angleSlider">
        Barrel angle (째)
        <span class="value-badge" id="angleValue">30째</span>
      </label>
      <input type="range" id="angleSlider" min="10" max="60" step="1" value="30" />
    </div>

    <div class="control-group">
      <label for="powderSlider">
        Powder charge (kg)
        <span class="value-badge" id="powderValue">4.0 kg</span>
      </label>
      <input type="range" id="powderSlider" min="1" max="8" step="0.5" value="4" />
    </div>

    <div class="control-group">
      <label for="fuseSlider">
        Fuse time (s)
        <span class="value-badge" id="fuseValue">2.0 s</span>
      </label>
      <input type="range" id="fuseSlider" min="0.5" max="5" step="0.1" value="2" />
    </div>

    <button id="fireBtn">Light Fuse</button>
  </div>

  <canvas id="simCanvas" width="800" height="400"></canvas>

  <div class="note">
    A heavier powder charge gives the stone ball a higher muzzle velocity, while a longer fuse adds tension before the
    shot. This is a simplified model of a huge bronze bombard, not precise ballistics.
  </div>

  <script>
    // ====== Basic setup ======
    const canvas = document.getElementById("simCanvas");
    const ctx = canvas.getContext("2d");
    
    let zoom = 0.7

    const angleSlider = document.getElementById("angleSlider");
    const angleValueLabel = document.getElementById("angleValue");
    const powderSlider = document.getElementById("powderSlider");
    const powderValueLabel = document.getElementById("powderValue");
    const fuseSlider = document.getElementById("fuseSlider");
    const fuseValueLabel = document.getElementById("fuseValue");
    const fireBtn = document.getElementById("fireBtn");

    angleValueLabel.textContent = angleSlider.value + "째";
    powderValueLabel.textContent = powderSlider.value + " kg";
    fuseValueLabel.textContent = fuseSlider.value + " s";

    angleSlider.addEventListener("input", () => {
      angleValueLabel.textContent = angleSlider.value + "째";
      if (phase === "idle") draw();
    });

    powderSlider.addEventListener("input", () => {
      powderValueLabel.textContent = powderSlider.value + " kg";
    });

    fuseSlider.addEventListener("input", () => {
      fuseValueLabel.textContent = fuseSlider.value + " s";
    });

    // ====== World / physics parameters ======
    const pxPerMeter = 60;
    const worldWidth = canvas.width / pxPerMeter;
    const worldHeight = canvas.height / pxPerMeter;

    // Ground at y=0 (world coords), y up.
    const bombardX = 2.0;   // base near left
    const bombardY = 0.6;   // center of barrel above ground
    const barrelLength = 2.5; // meters (short massive bombard)
    const stoneMass = 300;  // kg, huge stone ball
    const g = -9.81;

    let powderMass = parseFloat(powderSlider.value);

    const projectile = {
      active: false,
      x: 0,
      y: 0,
      vx: 0,
      vy: 0,
      trail: []
    };

    // Phases: "idle", "fuse", "projectile"
    let phase = "idle";
    let remainingFuse = 0;
    let flashTimer = 0;
    let smokeTimer = 0;
    let recoil = 0;
    let lockedAngleRad = null;
    let lastTimestamp = null;

    // ====== World -> Screen ======
    function worldToScreen(xWorld, yWorld) {
      const xScreen = xWorld * pxPerMeter;
      const yScreen = canvas.height - yWorld * pxPerMeter;
      return { x: xScreen, y: yScreen };
    }

    // ====== Angle handling ======
    function getCannonAngleRad() {
      if (phase === "idle" || lockedAngleRad === null) {
        return (parseFloat(angleSlider.value) * Math.PI) / 180;
      }
      return lockedAngleRad;
    }

    // ====== Firing logic with fuse ======
    function startFuse() {
      if (phase !== "idle") return; // full fuse only, no spam

      powderMass = parseFloat(powderSlider.value);
      remainingFuse = parseFloat(fuseSlider.value);
      lockedAngleRad = (parseFloat(angleSlider.value) * Math.PI) / 180;

      projectile.active = false;
      projectile.trail = [];
      flashTimer = 0;
      smokeTimer = 0;
      recoil = 0;

      phase = "fuse";
      lastTimestamp = null;
      requestAnimationFrame(loop);
    }

    fireBtn.addEventListener("click", startFuse);

    function igniteCannon() {
      const angle = lockedAngleRad;
      const muzzleX = bombardX + barrelLength * Math.cos(angle);
      const muzzleY = bombardY + barrelLength * Math.sin(angle);

      // crude empirical: bigger powder/stone ratio -> higher speed, but capped
      const baseSpeed = 80; // tuning constant
      const energy = 120000 * powderMass;        // joules-ish
const speed = Math.sqrt((2 * energy) / stoneMass);

      projectile.active = true;
      projectile.x = muzzleX;
      projectile.y = muzzleY;
      projectile.vx = speed * Math.cos(angle);
      projectile.vy = speed * Math.sin(angle);
      projectile.trail = [{ x: muzzleX, y: muzzleY }];
      
     projectile.smokePuffs = [];
for (let i = 0; i < 4; i++) { // fewer puffs
  projectile.smokePuffs.push({
    x: muzzleX,
    y: muzzleY,
    size: 10 + Math.random() * 15,   // smaller puffs
    alpha: 0.35 + Math.random() * 0.15, // much more transparent
    vx: (Math.random() - 0.5) * 0.2, // move less
    vy: (Math.random() * 0.3),
    fade: 0.8 + Math.random() * 0.4  // fade out faster
  });
}

      flashTimer = 0.15;
      smokeTimer = 0.7;
      recoil = 0.4;
    }

    // ====== Physics step ======
    function step(dt) {
      if (phase === "fuse") {
        remainingFuse -= dt;
        if (remainingFuse <= 0) {
          remainingFuse = 0;
          igniteCannon();
          phase = "projectile";
        }
      }

      if (phase === "projectile" && projectile.active) {
        projectile.vy += g * dt;
        projectile.x += projectile.vx * dt;
        projectile.y += projectile.vy * dt;

        projectile.trail.push({ x: projectile.x, y: projectile.y });
        if (projectile.trail.length > 200) {
          projectile.trail.shift();
        }

        if (projectile.y <= 0) {
          projectile.y = 0;
          projectile.vy = 0;
          projectile.active = false;
        }
      }

      // Recoil relaxes back
      recoil *= 0.9;
      if (recoil < 0.001) recoil = 0;

      flashTimer = Math.max(0, flashTimer - dt);
      smokeTimer = Math.max(0, smokeTimer - dt);

      // When everything finishes, go back to idle
      if (
        phase === "projectile" &&
        !projectile.active &&
        flashTimer <= 0.01 &&
        smokeTimer <= 0.01 &&
        recoil < 0.002
      ) {
        phase = "idle";
        lockedAngleRad = null;
      }
      
      if (projectile.smokePuffs) {
  for (let puff of projectile.smokePuffs) {
    puff.x += puff.vx;
    puff.y += puff.vy * dt;
    puff.alpha -= puff.fade * dt;
  }
  projectile.smokePuffs = projectile.smokePuffs.filter(p => p.alpha > 0);
}
    }

    // ====== Drawing helpers ======
    function drawBackgroundSky() {
      const groundY = worldToScreen(0, 0).y;
      const gradient = ctx.createLinearGradient(0, groundY - 100, 0, groundY);
      gradient.addColorStop(0, "rgba(255, 255, 255, 0)");
      gradient.addColorStop(1, "rgba(255, 255, 255, 0.2)");
      ctx.fillStyle = gradient;
      ctx.fillRect(0, groundY - 100, canvas.width, 100);
    }

    function drawGround() {
      ctx.save();
      const groundY = worldToScreen(0, 0).y;

      ctx.fillStyle = "#2e7d32";
      ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);

      ctx.strokeStyle = "#14532d";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, groundY);
      ctx.lineTo(canvas.width, groundY);
      ctx.stroke();

      ctx.restore();
    }

    function drawCannon() {
      const angle = getCannonAngleRad();

      // Wooden firing platform (no wheels, just a big bed)
      const platformWidth = 2.6;  // meters
      const platformHeight = 0.25;
      const platformX = bombardX - recoil - platformWidth * 0.7;
      const platformY = 0.1;

      const platTopLeft = worldToScreen(platformX, platformY + platformHeight);
      const platBottomRight = worldToScreen(platformX + platformWidth, platformY);

      ctx.fillStyle = "#8d5524";
      ctx.fillRect(
        platTopLeft.x,
        platTopLeft.y,
        platBottomRight.x - platTopLeft.x,
        platBottomRight.y - platTopLeft.y
      );

      // Simple angled braces
      ctx.fillStyle = "#6b4f2a";
      const braceBase = worldToScreen(bombardX - recoil, platformY + platformHeight).x;
      const braceTop = worldToScreen(bombardX - recoil + 0.4, platformY + platformHeight + 0.6).y;
      ctx.beginPath();
      ctx.moveTo(braceBase - 40, platTopLeft.y);
      ctx.lineTo(braceBase + 30, platTopLeft.y);
      ctx.lineTo(braceBase, braceTop);
      ctx.closePath();
      ctx.fill();

      // Cannon barrel (short, thick bombard)
      const barrelBaseScreen = worldToScreen(bombardX - recoil, bombardY);

      ctx.save();
      ctx.translate(barrelBaseScreen.x, barrelBaseScreen.y);
      ctx.rotate(-angle);

      // Main barrel
      ctx.fillStyle = "#1f2937";
      ctx.fillRect(-25, -18, barrelLength * pxPerMeter + 20, 36);

      // Slightly flared muzzle
     

      // Iron hoops
      ctx.strokeStyle = "#374151";
      ctx.lineWidth = 3;
      [10, 35, 60].forEach((h) => {
        ctx.beginPath();
        ctx.moveTo(h, -20);
        ctx.lineTo(h, 20);
        ctx.stroke();
      });

      // Fuse sparks during fuse phase
      if (phase === "fuse" && remainingFuse > 0) {
        const flicker = 0.5 + Math.random() * 0.5;
        ctx.fillStyle = "rgba(255, 180, 60," + (0.6 + Math.random()*0.4) + ")";
ctx.beginPath();
ctx.arc(-15, -25, 12 + Math.random() * 6, 0, Math.PI * 2);
ctx.fill();
      }

      // Muzzle flash
      if (flashTimer > 0) {
        const alpha = flashTimer / 0.15;
        ctx.fillStyle = "rgba(255, 230, 120," + alpha + ")";
        ctx.beginPath();
        ctx.arc(barrelLength * pxPerMeter + 15, 0, 28 * alpha, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.restore();

      // Smoke cloud from muzzle
      if (smokeTimer > 0) {
        const angle2 = getCannonAngleRad();
        const muzzleWorldX = (bombardX - recoil) + barrelLength * Math.cos(angle2);
        const muzzleWorldY = bombardY + barrelLength * Math.sin(angle2);
        const muzzleScreen = worldToScreen(muzzleWorldX, muzzleWorldY);

        const alpha = smokeTimer / 0.7;
        ctx.fillStyle = "rgba(229, 231, 235," + alpha + ")";
        ctx.beginPath();
        ctx.arc(
          muzzleScreen.x,
          muzzleScreen.y,
          26 * (1 - alpha + 0.3),
          0,
          Math.PI * 2
        );
        ctx.fill();
      }

      // Fuse countdown text
      if (phase === "fuse") {
        ctx.fillStyle = "#111827";
        ctx.font = "12px system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif";
        const text = "Fuse: " + remainingFuse.toFixed(1) + " s";
        const labelPos = worldToScreen(bombardX - recoil, bombardY + 1.0);
        ctx.fillText(text, labelPos.x - 35, labelPos.y);
      }
    }

    function drawProjectile() {
        if (projectile.smokePuffs) {
  for (let puff of projectile.smokePuffs) {
    const s = worldToScreen(puff.x, puff.y);
    ctx.fillStyle = "rgba(230, 230, 230, " + puff.alpha + ")";
    ctx.beginPath();
    ctx.arc(s.x, s.y, puff.size * (0.4 + puff.alpha), 0, Math.PI * 2);
    ctx.fill();
  }
}
        
      if (!projectile.active) return;

      ctx.save();

      // Trajectory trail
      if (projectile.trail.length > 1) {
        ctx.lineWidth = 2;
        ctx.strokeStyle = "rgba(75, 85, 99, 0.7)";
        ctx.beginPath();
        const first = worldToScreen(projectile.trail[0].x, projectile.trail[0].y);
        ctx.moveTo(first.x, first.y);
        for (let i = 1; i < projectile.trail.length; i++) {
          const p = worldToScreen(projectile.trail[i].x, projectile.trail[i].y);
          ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
      }

      // Stone ball
      const stoneScreen = worldToScreen(projectile.x, projectile.y);
      ctx.fillStyle = "#d1d5db";
      ctx.beginPath();
      ctx.arc(stoneScreen.x, stoneScreen.y, 15, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  ctx.save();

    if (phase === "fuse") {
    const powder = parseFloat(powderSlider.value);

    // Base shake = 0.2, plus 0.2 per kg of powder
    const shake = 0.2 + powder * 0.2;

    ctx.translate(
      (Math.random() - 0.5) * shake,
      (Math.random() - 0.5) * shake
    );
}

  // Anchor zoom to bottom-left of canvas
  ctx.translate(0, canvas.height * (1 - zoom));
  ctx.scale(zoom, zoom);

  // Draw world elements at zoomed scale
  drawGround();
  drawCannon();
  drawProjectile();

  ctx.restore();

  // Draw non-zoomed sky overlay
  drawBackgroundSky();
}

    // ====== Animation loop ======
    function loop(timestamp) {
      if (!lastTimestamp) lastTimestamp = timestamp;
      let dt = (timestamp - lastTimestamp) / 1000;
      lastTimestamp = timestamp;

      dt = Math.min(dt, 0.03);

      step(dt);
      draw();

      if (
        phase !== "idle" ||
        projectile.active ||
        flashTimer > 0.01 ||
        smokeTimer > 0.01
      ) {
        requestAnimationFrame(loop);
      }
    }

    // Initial static render
    draw();
  </script>
</body>
</html>
